package com.bigdata.etl.mr;

import org.apache.commons.io.IOExceptionWithCause;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FSDataOutputStream;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.compress.CompressionCodec;
import org.apache.hadoop.io.compress.GzipCodec;
import org.apache.hadoop.mapreduce.OutputCommitter;
import org.apache.hadoop.mapreduce.RecordWriter;
import org.apache.hadoop.mapreduce.TaskAttemptContext;
import org.apache.hadoop.mapreduce.TaskID;
import org.apache.hadoop.mapreduce.lib.output.FileOutputCommitter;
import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;
import org.apache.hadoop.util.ReflectionUtils;

import java.io.DataOutputStream;
import java.io.IOException;
import java.text.NumberFormat;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class LogOutputFormat<K, V> extends TextOutputFormat<K, V> {
    private static final NumberFormat NUMBER_FORMAT = NumberFormat.getInstance();

    static {
        NUMBER_FORMAT.setMinimumIntegerDigits(5);
        NUMBER_FORMAT.setGroupingUsed(false);
    }

    private RecordWriter writer = null;

    public RecordWriter<K, V> getRecordWriter(TaskAttemptContext job) throws IOException, InterruptedException{
        if(writer == null ){
            writer = new MultiRecordWriter(job, getTaskOutputPath(job));
        }

        return writer;
    }

    private Path getTaskOutputPath(TaskAttemptContext conf) throws IOException{
        Path taskOutputPath;
        OutputCommitter committer = getOutputCommitter(conf);
        if(committer instanceof FileOutputCommitter){
            taskOutputPath = ((FileOutputCommitter) committer).getWorkPath();
        } else {
            Path outputPath =getOutputPath(conf);
            if (outputPath == null){
                throw new IOException("Undefined job output path");
            }
            taskOutputPath = outputPath;
        }
        return taskOutputPath;
    }

    public class MultiRecordWriter extends  RecordWriter<K, V>{
        private Map<String,RecordWriter<K, V>> recordWriters;
        private TaskAttemptContext job;
        private Path outputPath;

        public MultiRecordWriter(TaskAttemptContext job, Path outputPath) {
            super();
            this.job = job;
            this.outputPath = outputPath;
            this.recordWriters = new HashMap<String, RecordWriter<K, V>>();
        }

        private String getfFileBaseName(K key,String name){
            return new StringBuilder(60).append(key.toString()).append("-").append(name).toString();
        }

        @Override
        public void write(K key, V value) throws IOException, InterruptedException {
            TaskID taskID = job.getTaskAttemptID().getTaskID();
            int partition = taskID.getId();
            String baseName = getfFileBaseName(key,NUMBER_FORMAT.format(partition));
            RecordWriter<K, V> rw =this.recordWriters.get(baseName);
            if(rw == null){
                rw = getBaseRecordWriter(job, baseName);
                this.recordWriters.put(baseName, rw);
            }

            rw.write(null,value);


        }

        @Override
        public void close(TaskAttemptContext context) throws IOException, InterruptedException {
            Iterator<RecordWriter<K, V>> values = this.recordWriters.values().iterator();
            while(values.hasNext()){
                values.next().close(context);
            }
            this.recordWriters.clear();
        }
        private  RecordWriter<K, V> getBaseRecordWriter(TaskAttemptContext job,String baseName) throws IOException, InterruptedException{
            RecordWriter<K, V> recordWriter;
            boolean isCompressed = getCompressOutput(job);
            Configuration conf = job.getConfiguration();
            if (isCompressed){
                Class<? extends CompressionCodec> codecClass =getOutputCompressorClass(job, GzipCodec.class);
                CompressionCodec codec = ReflectionUtils.newInstance(codecClass,conf);
                Path file = new Path(outputPath, baseName + codec.getDefaultExtension());
                FSDataOutputStream fileOut =file.getFileSystem(conf).create(file,false);
                recordWriter = new LineRecordWriter<K, V>(new DataOutputStream(codec.createOutputStream(fileOut)));
            } else {
                Path file = new Path(outputPath,baseName);
                FSDataOutputStream fileout =file.getFileSystem(conf).create(file,false);
                recordWriter = new LineRecordWriter<K, V>(fileout);
            }
            return recordWriter;
        }
    }
}
